//
//  SMGAssignmentMocks.generated.swift
//  SMGAssignment
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

#if !(os(macOS))
import UIKit
#endif
#if os(macOS)
import AppKit
#endif
@testable import Mockingbird
@testable import SMGAssignment
import ACarousel
import BetterCodable
import Combine
import Foundation
import Swift
import SwiftUI
import UIKit

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked ACarouselViewModel
public final class ACarouselViewModelMock<Data, ID>: SMGAssignment.ACarouselViewModel<Data, ID>, Mockingbird.Mock where Data: RandomAccessCollection, ID: Swift.Hashable {
  typealias MockingbirdSupertype = SMGAssignment.ACarouselViewModel<Data, ID>
  public static var mockingbirdContext: Mockingbird.Context { return mkbGenericStaticMockContext.resolve(["ACarouselViewModelMock<Data, ID>", Swift.ObjectIdentifier(Data.self).debugDescription, Swift.ObjectIdentifier(ID.self).debugDescription]) }
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  public enum InitializerProxy {
    public static func initialize(_ `data`: Data, `id`: KeyPath<Data.Element, ID>, `index`: Binding<Int>, `spacing`: CGFloat, `headspace`: CGFloat, `sidesScaling`: CGFloat, `isWrap`: Bool, `autoScroll`: SMGAssignment.ACarouselAutoScroll, __file: StaticString = #file, __line: UInt = #line) -> ACarouselViewModelMock<Data, ID> {
      let mock: ACarouselViewModelMock<Data, ID> = ACarouselViewModelMock<Data, ID>(`data`, id: `id`, index: `index`, spacing: `spacing`, headspace: `headspace`, sidesScaling: `sidesScaling`, isWrap: `isWrap`, autoScroll: `autoScroll`)
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked activeIndex
  override public var `activeIndex`: Int {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "activeIndex.getter", setterSelectorName: "activeIndex.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((Int).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> Int { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Int }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`activeIndex`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Int = mkbObject.`activeIndex`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Int).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "activeIndex.setter", setterSelectorName: "activeIndex.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (Int) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`activeIndex` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`activeIndex` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getActiveIndex() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Int, Int> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Int, Int>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "activeIndex.getter", setterSelectorName: "activeIndex.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((Int).self)))
  }

  public func setActiveIndex(_ newValue: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Int) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Int) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "activeIndex.setter", setterSelectorName: "activeIndex.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked dragOffset
  override public var `dragOffset`: CGFloat {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "dragOffset.getter", setterSelectorName: "dragOffset.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((CGFloat).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> CGFloat { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as CGFloat }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`dragOffset`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: CGFloat = mkbObject.`dragOffset`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (CGFloat).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "dragOffset.setter", setterSelectorName: "dragOffset.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (CGFloat) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`dragOffset` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`dragOffset` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getDragOffset() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> CGFloat, CGFloat> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> CGFloat, CGFloat>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "dragOffset.getter", setterSelectorName: "dragOffset.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((CGFloat).self)))
  }

  public func setDragOffset(_ newValue: @autoclosure () -> CGFloat) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (CGFloat) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (CGFloat) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "dragOffset.setter", setterSelectorName: "dragOffset.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked viewSize
  override public var `viewSize`: CGSize {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "viewSize.getter", setterSelectorName: "viewSize.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((CGSize).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> CGSize { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as CGSize }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`viewSize`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: CGSize = mkbObject.`viewSize`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (CGSize).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "viewSize.setter", setterSelectorName: "viewSize.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (CGSize) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`viewSize` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`viewSize` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getViewSize() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> CGSize, CGSize> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> CGSize, CGSize>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "viewSize.getter", setterSelectorName: "viewSize.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((CGSize).self)))
  }

  public func setViewSize(_ newValue: @autoclosure () -> CGSize) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (CGSize) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (CGSize) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "viewSize.setter", setterSelectorName: "viewSize.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked `setTimerActive`(_ `active`: Bool)
  public override func `setTimerActive`(_ `active`: Bool) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`setTimerActive`(_ `active`: Bool) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`active`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Bool) -> Void { return mkbImpl(`active`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`setTimerActive`(`active`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`setTimerActive`(`active`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `setTimerActive`(_ `active`: @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Bool) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`setTimerActive`(_ `active`: Bool) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`active`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked init(_ `data`: Data, `id`: KeyPath<Data.Element, ID>, `index`: Binding<Int>, `spacing`: CGFloat, `headspace`: CGFloat, `sidesScaling`: CGFloat, `isWrap`: Bool, `autoScroll`: SMGAssignment.ACarouselAutoScroll)
  public required override init(_ `data`: Data, `id`: KeyPath<Data.Element, ID>, `index`: Binding<Int>, `spacing`: CGFloat, `headspace`: CGFloat, `sidesScaling`: CGFloat, `isWrap`: Bool, `autoScroll`: SMGAssignment.ACarouselAutoScroll) {
    super.init(`data`, id: `id`, index: `index`, spacing: `spacing`, headspace: `headspace`, sidesScaling: `sidesScaling`, isWrap: `isWrap`, autoScroll: `autoScroll`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init(_ `data`: Data, `id`: KeyPath<Data.Element, ID>, `index`: Binding<Int>, `spacing`: CGFloat, `headspace`: CGFloat, `sidesScaling`: CGFloat, `isWrap`: Bool, `autoScroll`: SMGAssignment.ACarouselAutoScroll)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`data`), Mockingbird.ArgumentMatcher(`id`), Mockingbird.ArgumentMatcher(`index`), Mockingbird.ArgumentMatcher(`spacing`), Mockingbird.ArgumentMatcher(`headspace`), Mockingbird.ArgumentMatcher(`sidesScaling`), Mockingbird.ArgumentMatcher(`isWrap`), Mockingbird.ArgumentMatcher(`autoScroll`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize(_ `data`: @autoclosure () -> Data, `id`: @autoclosure () -> KeyPath<Data.Element, ID>, `index`: @autoclosure () -> Binding<Int>, `spacing`: @autoclosure () -> CGFloat, `headspace`: @autoclosure () -> CGFloat, `sidesScaling`: @autoclosure () -> CGFloat, `isWrap`: @autoclosure () -> Bool, `autoScroll`: @autoclosure () -> SMGAssignment.ACarouselAutoScroll) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Data, KeyPath<Data.Element, ID>, Binding<Int>, CGFloat, CGFloat, CGFloat, Bool, SMGAssignment.ACarouselAutoScroll) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Data, KeyPath<Data.Element, ID>, Binding<Int>, CGFloat, CGFloat, CGFloat, Bool, SMGAssignment.ACarouselAutoScroll) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init(_ `data`: Data, `id`: KeyPath<Data.Element, ID>, `index`: Binding<Int>, `spacing`: CGFloat, `headspace`: CGFloat, `sidesScaling`: CGFloat, `isWrap`: Bool, `autoScroll`: SMGAssignment.ACarouselAutoScroll)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`data`), Mockingbird.resolve(`id`), Mockingbird.resolve(`index`), Mockingbird.resolve(`spacing`), Mockingbird.resolve(`headspace`), Mockingbird.resolve(`sidesScaling`), Mockingbird.resolve(`isWrap`), Mockingbird.resolve(`autoScroll`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(ACarouselViewModel.self).initialize(â€¦)`.
public func mock<Data, ID>(_ type: SMGAssignment.ACarouselViewModel<Data, ID>.Type, file: StaticString = #file, line: UInt = #line) -> ACarouselViewModelMock<Data, ID>.InitializerProxy.Type {
  return ACarouselViewModelMock<Data, ID>.InitializerProxy.self
}

// MARK: - Mocked APITargetProtocol
public final class APITargetProtocolMock: SMGAssignment.APITargetProtocol, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.APITargetProtocol
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  // MARK: Mocked headers
  public var `headers`: [String: String] {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "headers.getter", setterSelectorName: "headers.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier(([String: String]).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> [String: String] { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as [String: String] }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: [String: String] = mkbObject.`headers`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: ([String: String]).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getHeaders() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [String: String], [String: String]> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [String: String], [String: String]>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "headers.getter", setterSelectorName: "headers.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier(([String: String]).self)))
  }

  // MARK: Mocked method
  public var `method`: SMGAssignment.APIMethod {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "method.getter", setterSelectorName: "method.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((SMGAssignment.APIMethod).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> SMGAssignment.APIMethod { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as SMGAssignment.APIMethod }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: SMGAssignment.APIMethod = mkbObject.`method`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (SMGAssignment.APIMethod).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getMethod() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> SMGAssignment.APIMethod, SMGAssignment.APIMethod> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> SMGAssignment.APIMethod, SMGAssignment.APIMethod>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "method.getter", setterSelectorName: "method.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((SMGAssignment.APIMethod).self)))
  }

  // MARK: Mocked parameters
  public var `parameters`: Swift.Encodable {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "parameters.getter", setterSelectorName: "parameters.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((Swift.Encodable).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> Swift.Encodable { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Swift.Encodable }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Swift.Encodable = mkbObject.`parameters`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Swift.Encodable).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getParameters() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Swift.Encodable, Swift.Encodable> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Swift.Encodable, Swift.Encodable>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "parameters.getter", setterSelectorName: "parameters.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((Swift.Encodable).self)))
  }

  // MARK: Mocked urlString
  public var `urlString`: String {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "urlString.getter", setterSelectorName: "urlString.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as String }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: String = mkbObject.`urlString`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getUrlString() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "urlString.getter", setterSelectorName: "urlString.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    APITargetProtocolMock.mockingbirdContext.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `APITargetProtocol`.
public func mock(_ type: SMGAssignment.APITargetProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> APITargetProtocolMock {
  return APITargetProtocolMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked BaseObserved
public final class BaseObservedMock<Output>: SMGAssignment.BaseObserved<Output>, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.BaseObserved<Output>
  public static var mockingbirdContext: Mockingbird.Context { return mkbGenericStaticMockContext.resolve(["BaseObservedMock<Output>", Swift.ObjectIdentifier(Output.self).debugDescription]) }
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  // MARK: Mocked state
  override public var `state`: SMGAssignment.LoadingState<Output> {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "state.getter", setterSelectorName: "state.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((SMGAssignment.LoadingState<Output>).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> SMGAssignment.LoadingState<Output> { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as SMGAssignment.LoadingState<Output> }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`state`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: SMGAssignment.LoadingState<Output> = mkbObject.`state`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (SMGAssignment.LoadingState<Output>).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "state.setter", setterSelectorName: "state.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (SMGAssignment.LoadingState<Output>) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`state` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`state` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getState() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> SMGAssignment.LoadingState<Output>, SMGAssignment.LoadingState<Output>> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> SMGAssignment.LoadingState<Output>, SMGAssignment.LoadingState<Output>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "state.getter", setterSelectorName: "state.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((SMGAssignment.LoadingState<Output>).self)))
  }

  public func setState(_ newValue: @autoclosure () -> SMGAssignment.LoadingState<Output>) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (SMGAssignment.LoadingState<Output>) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (SMGAssignment.LoadingState<Output>) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "state.setter", setterSelectorName: "state.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    self.mockingbirdContext.sourceLocation = sourceLocation
    BaseObservedMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `load`()
  public override func `load`() -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`load`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`load`()
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`load`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `load`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`load`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns a concrete mock of `BaseObserved`.
public func mock<Output>(_ type: SMGAssignment.BaseObserved<Output>.Type, file: StaticString = #file, line: UInt = #line) -> BaseObservedMock<Output> {
  return BaseObservedMock<Output>(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked Currency
public final class CurrencyMock: SMGAssignment.Currency, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.Currency
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    self.mockingbirdContext.sourceLocation = sourceLocation
    CurrencyMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `findSymbol`(`currencyCode`: String)
  public override func `findSymbol`(`currencyCode`: String) -> String {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`findSymbol`(`currencyCode`: String) -> String", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`currencyCode`)], returnType: Swift.ObjectIdentifier((String).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String) -> String { return mkbImpl(`currencyCode`) }
      if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`findSymbol`(currencyCode: `currencyCode`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: String = mkbObject.`findSymbol`(currencyCode: `currencyCode`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `findSymbol`(`currencyCode`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`findSymbol`(`currencyCode`: String) -> String", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`currencyCode`)], returnType: Swift.ObjectIdentifier((String).self)))
  }
}

/// Returns a concrete mock of `Currency`.
public func mock(_ type: SMGAssignment.Currency.Type, file: StaticString = #file, line: UInt = #line) -> CurrencyMock {
  return CurrencyMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked InjectionKey
public final class InjectionKeyMock<Value>: SMGAssignment.InjectionKey, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.InjectionKey
  public static var mockingbirdContext: Mockingbird.Context { return mkbGenericStaticMockContext.resolve(["InjectionKeyMock<Value>", Swift.ObjectIdentifier(Value.self).debugDescription]) }
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  // MARK: Mocked currentValue
  public class var `currentValue`: InjectionKeyMock.Value {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "currentValue.getter", setterSelectorName: "currentValue.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((InjectionKeyMock.Value).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> InjectionKeyMock.Value { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as InjectionKeyMock.Value }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object:
            break
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (InjectionKeyMock.Value).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "currentValue.setter", setterSelectorName: "currentValue.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (InjectionKeyMock.Value) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object:
            break
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public class func getCurrentValue() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> InjectionKeyMock.Value, InjectionKeyMock.Value> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> InjectionKeyMock.Value, InjectionKeyMock.Value>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "currentValue.getter", setterSelectorName: "currentValue.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((InjectionKeyMock.Value).self)))
  }

  public class func setCurrentValue(_ newValue: @autoclosure () -> InjectionKeyMock.Value) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (InjectionKeyMock.Value) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (InjectionKeyMock.Value) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "currentValue.setter", setterSelectorName: "currentValue.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    InjectionKeyMock.mockingbirdContext.sourceLocation = sourceLocation
  }
}

public enum InjectionKey<Value> {
}
/// Returns a concrete mock of `InjectionKey`.
public func mock<Value>(_ type: InjectionKey<Value>.Type, file: StaticString = #file, line: UInt = #line) -> InjectionKeyMock<Value> {
  return InjectionKeyMock<Value>(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ListingServiceProtocol
public final class ListingServiceProtocolMock: SMGAssignment.ListingServiceProtocol, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.ListingServiceProtocol
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ListingServiceProtocolMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getListings`()
  public func `getListings`() -> AnyPublisher<SMGAssignment.ListingResponse, Error> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getListings`() -> AnyPublisher<SMGAssignment.ListingResponse, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((AnyPublisher<SMGAssignment.ListingResponse, Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> AnyPublisher<SMGAssignment.ListingResponse, Error> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: AnyPublisher<SMGAssignment.ListingResponse, Error> = mkbObject.`getListings`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnyPublisher<SMGAssignment.ListingResponse, Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getListings`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> AnyPublisher<SMGAssignment.ListingResponse, Error>, AnyPublisher<SMGAssignment.ListingResponse, Error>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> AnyPublisher<SMGAssignment.ListingResponse, Error>, AnyPublisher<SMGAssignment.ListingResponse, Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getListings`() -> AnyPublisher<SMGAssignment.ListingResponse, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((AnyPublisher<SMGAssignment.ListingResponse, Error>).self)))
  }

  // MARK: Mocked `getListings`()
  public func `getListings`() async throws -> SMGAssignment.ListingResponse {
    return try await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getListings`() async throws -> SMGAssignment.ListingResponse", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((SMGAssignment.ListingResponse).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async throws -> SMGAssignment.ListingResponse { return try await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: SMGAssignment.ListingResponse = try await mkbObject.`getListings`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (SMGAssignment.ListingResponse).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getListings`() async -> Mockingbird.Mockable<Mockingbird.ThrowingAsyncFunctionDeclaration, () async throws -> SMGAssignment.ListingResponse, SMGAssignment.ListingResponse> {
    return Mockingbird.Mockable<Mockingbird.ThrowingAsyncFunctionDeclaration, () async throws -> SMGAssignment.ListingResponse, SMGAssignment.ListingResponse>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getListings`() async throws -> SMGAssignment.ListingResponse", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((SMGAssignment.ListingResponse).self)))
  }
}

/// Returns a concrete mock of `ListingServiceProtocol`.
public func mock(_ type: SMGAssignment.ListingServiceProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> ListingServiceProtocolMock {
  return ListingServiceProtocolMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ListingService
public final class ListingServiceMock: SMGAssignment.ListingService, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.ListingService
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  // MARK: Mocked cancellables
  override public var `cancellables`: Set<AnyCancellable> {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "cancellables.getter", setterSelectorName: "cancellables.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((Set<AnyCancellable>).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> Set<AnyCancellable> { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Set<AnyCancellable> }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`cancellables`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Set<AnyCancellable> = mkbObject.`cancellables`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Set<AnyCancellable>).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "cancellables.setter", setterSelectorName: "cancellables.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (Set<AnyCancellable>) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`cancellables` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`cancellables` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getCancellables() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Set<AnyCancellable>, Set<AnyCancellable>> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> Set<AnyCancellable>, Set<AnyCancellable>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "cancellables.getter", setterSelectorName: "cancellables.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((Set<AnyCancellable>).self)))
  }

  public func setCancellables(_ newValue: @autoclosure () -> Set<AnyCancellable>) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Set<AnyCancellable>) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (Set<AnyCancellable>) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "cancellables.setter", setterSelectorName: "cancellables.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    self.mockingbirdContext.sourceLocation = sourceLocation
    ListingServiceMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getListings`()
  public override func `getListings`() -> AnyPublisher<SMGAssignment.ListingResponse, Error> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getListings`() -> AnyPublisher<SMGAssignment.ListingResponse, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((AnyPublisher<SMGAssignment.ListingResponse, Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> AnyPublisher<SMGAssignment.ListingResponse, Error> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`getListings`()
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: AnyPublisher<SMGAssignment.ListingResponse, Error> = mkbObject.`getListings`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnyPublisher<SMGAssignment.ListingResponse, Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getListings`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> AnyPublisher<SMGAssignment.ListingResponse, Error>, AnyPublisher<SMGAssignment.ListingResponse, Error>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> AnyPublisher<SMGAssignment.ListingResponse, Error>, AnyPublisher<SMGAssignment.ListingResponse, Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getListings`() -> AnyPublisher<SMGAssignment.ListingResponse, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((AnyPublisher<SMGAssignment.ListingResponse, Error>).self)))
  }

  // MARK: Mocked `getListings`()
  public override func `getListings`() async throws -> SMGAssignment.ListingResponse {
    return try await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getListings`() async throws -> SMGAssignment.ListingResponse", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((SMGAssignment.ListingResponse).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async throws -> SMGAssignment.ListingResponse { return try await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return try await super.`getListings`()
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: SMGAssignment.ListingResponse = try await mkbObject.`getListings`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (SMGAssignment.ListingResponse).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getListings`() async -> Mockingbird.Mockable<Mockingbird.ThrowingAsyncFunctionDeclaration, () async throws -> SMGAssignment.ListingResponse, SMGAssignment.ListingResponse> {
    return Mockingbird.Mockable<Mockingbird.ThrowingAsyncFunctionDeclaration, () async throws -> SMGAssignment.ListingResponse, SMGAssignment.ListingResponse>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getListings`() async throws -> SMGAssignment.ListingResponse", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((SMGAssignment.ListingResponse).self)))
  }
}

/// Returns a concrete mock of `ListingService`.
public func mock(_ type: SMGAssignment.ListingService.Type, file: StaticString = #file, line: UInt = #line) -> ListingServiceMock {
  return ListingServiceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked LoadableObject
public final class LoadableObjectMock<Output>: SMGAssignment.LoadableObject, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.LoadableObject
  public static var mockingbirdContext: Mockingbird.Context { return mkbGenericStaticMockContext.resolve(["LoadableObjectMock<Output>", Swift.ObjectIdentifier(Output.self).debugDescription]) }
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  // MARK: Mocked state
  public var `state`: SMGAssignment.LoadingState<Output> {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "state.getter", setterSelectorName: "state.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((SMGAssignment.LoadingState<Output>).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> SMGAssignment.LoadingState<Output> { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as SMGAssignment.LoadingState<Output> }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            break
          case .object:
            break
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (SMGAssignment.LoadingState<Output>).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getState() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> SMGAssignment.LoadingState<Output>, SMGAssignment.LoadingState<Output>> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> SMGAssignment.LoadingState<Output>, SMGAssignment.LoadingState<Output>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "state.getter", setterSelectorName: "state.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((SMGAssignment.LoadingState<Output>).self)))
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    LoadableObjectMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `load`()
  public func `load`() -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`load`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object:
          break
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `load`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`load`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

public enum LoadableObject<Output> {
}
/// Returns a concrete mock of `LoadableObject`.
public func mock<Output>(_ type: LoadableObject<Output>.Type, file: StaticString = #file, line: UInt = #line) -> LoadableObjectMock<Output> {
  return LoadableObjectMock<Output>(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked LoggerDebug
public final class LoggerDebugMock: SMGAssignment.LoggerDebug, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.LoggerDebug
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    self.mockingbirdContext.sourceLocation = sourceLocation
    LoggerDebugMock.mockingbirdContext.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `LoggerDebug`.
public func mock(_ type: SMGAssignment.LoggerDebug.Type, file: StaticString = #file, line: UInt = #line) -> LoggerDebugMock {
  return LoggerDebugMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked NetworkUtility
public final class NetworkUtilityMock: SMGAssignment.NetworkUtility, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.NetworkUtility
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> NetworkUtilityMock {
      let mock: NetworkUtilityMock = NetworkUtilityMock()
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked urlSession
  override public var `urlSession`: URLSession {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "urlSession.getter", setterSelectorName: "urlSession.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((URLSession).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> URLSession { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as URLSession }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`urlSession`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: URLSession = mkbObject.`urlSession`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (URLSession).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "urlSession.setter", setterSelectorName: "urlSession.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (URLSession) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`urlSession` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`urlSession` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getUrlSession() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> URLSession, URLSession> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> URLSession, URLSession>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "urlSession.getter", setterSelectorName: "urlSession.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((URLSession).self)))
  }

  public func setUrlSession(_ newValue: @autoclosure () -> URLSession) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (URLSession) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (URLSession) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "urlSession.setter", setterSelectorName: "urlSession.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked `request`<T: Swift.Decodable>(`target`: any APITargetProtocol)
  public override func `request`<T: Swift.Decodable>(`target`: any APITargetProtocol) -> AnyPublisher<T, Error> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`request`<T: Swift.Decodable>(`target`: any APITargetProtocol) -> AnyPublisher<T, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`target`)], returnType: Swift.ObjectIdentifier((AnyPublisher<T, Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (any APITargetProtocol) -> AnyPublisher<T, Error> { return mkbImpl(`target`) }
      if let mkbImpl = mkbImpl as? () -> AnyPublisher<T, Error> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`request`(target: `target`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: AnyPublisher<T, Error> = mkbObject.`request`(target: `target`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnyPublisher<T, Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `request`<T: Swift.Decodable>(`target`: @autoclosure () -> any APITargetProtocol) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (any APITargetProtocol) -> AnyPublisher<T, Error>, AnyPublisher<T, Error>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (any APITargetProtocol) -> AnyPublisher<T, Error>, AnyPublisher<T, Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`request`<T: Swift.Decodable>(`target`: any APITargetProtocol) -> AnyPublisher<T, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`target`)], returnType: Swift.ObjectIdentifier((AnyPublisher<T, Error>).self)))
  }

  // MARK: Mocked `downloadImage`(`url`: URL)
  public override func `downloadImage`(`url`: URL) -> AnyPublisher<UIImage?, Error> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`downloadImage`(`url`: URL) -> AnyPublisher<UIImage?, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`url`)], returnType: Swift.ObjectIdentifier((AnyPublisher<UIImage?, Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (URL) -> AnyPublisher<UIImage?, Error> { return mkbImpl(`url`) }
      if let mkbImpl = mkbImpl as? () -> AnyPublisher<UIImage?, Error> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`downloadImage`(url: `url`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: AnyPublisher<UIImage?, Error> = mkbObject.`downloadImage`(url: `url`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnyPublisher<UIImage?, Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `downloadImage`(`url`: @autoclosure () -> URL) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (URL) -> AnyPublisher<UIImage?, Error>, AnyPublisher<UIImage?, Error>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (URL) -> AnyPublisher<UIImage?, Error>, AnyPublisher<UIImage?, Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`downloadImage`(`url`: URL) -> AnyPublisher<UIImage?, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`url`)], returnType: Swift.ObjectIdentifier((AnyPublisher<UIImage?, Error>).self)))
  }

  // MARK: Mocked init()
  public required override init() {
    super.init()
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init()", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init()", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(NetworkUtility.self).initialize(â€¦)`.
public func mock(_ type: SMGAssignment.NetworkUtility.Type, file: StaticString = #file, line: UInt = #line) -> NetworkUtilityMock.InitializerProxy.Type {
  return NetworkUtilityMock.InitializerProxy.self
}

// MARK: - Mocked Persistent
public final class PersistentMock<T>: SMGAssignment.Persistent<T>, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.Persistent<T>
  public static var mockingbirdContext: Mockingbird.Context { return mkbGenericStaticMockContext.resolve(["PersistentMock<T>", Swift.ObjectIdentifier(T.self).debugDescription]) }
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  public enum InitializerProxy {
    public static func initialize(`key`: String, `defaultValue`: T, __file: StaticString = #file, __line: UInt = #line) -> PersistentMock<T> {
      let mock: PersistentMock<T> = PersistentMock<T>(key: `key`, defaultValue: `defaultValue`)
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked value
  override public var `value`: T {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "value.getter", setterSelectorName: "value.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((T).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> T { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as T }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`value`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: T = mkbObject.`value`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (T).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "value.setter", setterSelectorName: "value.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (T) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`value` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`value` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getValue() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> T, T> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> T, T>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "value.getter", setterSelectorName: "value.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((T).self)))
  }

  public func setValue(_ newValue: @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (T) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (T) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "value.setter", setterSelectorName: "value.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked `removeObject`()
  public override func `removeObject`() -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`removeObject`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`removeObject`()
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`removeObject`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `removeObject`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`removeObject`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked init(`key`: String, `defaultValue`: T)
  public required override init(`key`: String, `defaultValue`: T) {
    super.init(key: `key`, defaultValue: `defaultValue`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init(`key`: String, `defaultValue`: T)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`key`), Mockingbird.ArgumentMatcher(`defaultValue`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize(`key`: @autoclosure () -> String, `defaultValue`: @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, T) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String, T) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init(`key`: String, `defaultValue`: T)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`key`), Mockingbird.resolve(`defaultValue`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(Persistent.self).initialize(â€¦)`.
public func mock<T>(_ type: SMGAssignment.Persistent<T>.Type, file: StaticString = #file, line: UInt = #line) -> PersistentMock<T>.InitializerProxy.Type {
  return PersistentMock<T>.InitializerProxy.self
}

// MARK: - Mocked PublishedObject
public final class PublishedObjectMock<Wrapped: Publisher>: SMGAssignment.PublishedObject<Wrapped>, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.PublishedObject<Wrapped>
  public static var mockingbirdContext: Mockingbird.Context { return mkbGenericStaticMockContext.resolve(["PublishedObjectMock<Wrapped>", Swift.ObjectIdentifier(Wrapped.self).debugDescription]) }
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  public enum InitializerProxy {
    public static func initialize(`publisher`: Wrapped, __file: StaticString = #file, __line: UInt = #line) -> PublishedObjectMock<Wrapped> {
      let mock: PublishedObjectMock<Wrapped> = PublishedObjectMock<Wrapped>(publisher: `publisher`)
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `load`()
  public override func `load`() -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`load`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`load`()
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`load`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `load`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`load`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked init(`publisher`: Wrapped)
  public required override init(`publisher`: Wrapped) {
    super.init(publisher: `publisher`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init(`publisher`: Wrapped)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`publisher`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize(`publisher`: @autoclosure () -> Wrapped) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Wrapped) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Wrapped) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init(`publisher`: Wrapped)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`publisher`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(PublishedObject.self).initialize(â€¦)`.
public func mock<Wrapped: Publisher>(_ type: SMGAssignment.PublishedObject<Wrapped>.Type, file: StaticString = #file, line: UInt = #line) -> PublishedObjectMock<Wrapped>.InitializerProxy.Type {
  return PublishedObjectMock<Wrapped>.InitializerProxy.self
}

// MARK: - Mocked Size
public final class SizeMock: SMGAssignment.Size, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.Size
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    self.mockingbirdContext.sourceLocation = sourceLocation
    SizeMock.mockingbirdContext.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `Size`.
public func mock(_ type: SMGAssignment.Size.Type, file: StaticString = #file, line: UInt = #line) -> SizeMock {
  return SizeMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked Spacing
public final class SpacingMock: SMGAssignment.Spacing, Mockingbird.Mock {
  typealias MockingbirdSupertype = SMGAssignment.Spacing
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "SMGAssignment"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    self.mockingbirdContext.sourceLocation = sourceLocation
    SpacingMock.mockingbirdContext.sourceLocation = sourceLocation
  }
}

/// Returns a concrete mock of `Spacing`.
public func mock(_ type: SMGAssignment.Spacing.Type, file: StaticString = #file, line: UInt = #line) -> SpacingMock {
  return SpacingMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
